1.
func Concat(s1, s2 string) string {
	bs := make([]byte, len(s1) + len(s2) )
	bl := 0
	bl += copy(bs[bl:], s1)
	copy(bs[bl:], s2)
	return string(bs)
}

2.
Интерфейс - именованный набор сигнатур методов
Выполняемая задача - объединение классов на основе набора одинаковых методов, который
эти самые классы реализуют
Наследование нескольких классов от одного интерфейса позволяет
этим самым классам быть, к примеру, взаимозаменяемыми в качестве параметров, возвращаемых значений
в методе, имеющих тип наследуемого интерфейса
(было применено мною в тестовом задании (паттерн фабричный метод))

3.
RWMutex позволяет множеству читателей получать доступ к ресурсу одновременно,
при том писатель, как и в Mutex блокирует остальных писателей

4.
Операция отправления в небуферизованный канал блокирует go-подпрограмму до тех пор, пока другая go-подпрограмма
не выполнит соответствующее получение из того же канала, после чего значение становится переданным, и обе go-подпрограммы продолжаются.
И наоборот, если первой сделана попытка выполнить операцию получения, принимающая go-подпрограмма блокируется до тех пор, пока другая go- подпрограмма
не выполнит отправление значения в тот же канал.
Связь по небуферизованному каналу приводит к синхронизации операций отправления и получения. По этой причине небуферизованные каналы иногда называют синхронными.
Когда значение отправляется в небуферизованный канал, получение значения предшествует продолжению работы отправляющей go-подпрограммы.

Буферизованный канал имеет очередь элементов. Максимальный размер очереди определяется при создании канала с помощью аргумента емкости функции make.
Операция отправления в буферизованный канал вставляет отправляемый элемент в конец очереди, а операция получения удаляет
первый элемент из очереди. Если канал заполнен, операция отправления блокирует свою go-подпрограмму до тех пор,
пока другая go-подпрограмма не освободит место, получив данные из канала. И наоборот, если канал пуст, операция получения
блокирует go-подпрограмму до того момента, пока в канал не будет послано значение из другой go-подпрограммы.
При применении к каналу встроенная функция len возвращает количество элементов, находящихся в настоящее время в буфере.

5.0 байт

6.нет

7.заранее нельзя сказать

8.
new возвращает адрес памяти выделенного объекта
память обнулена, но не инициализирована (поля структуры, к примеру, имеют значения по умолчанию)
sl := new([]int)
В этом примере команда new([]int) выделяет в памяти место под поля описания
среза, но так как поля описания среза не инициированы, возвращается указатель на nil.
Чтобы в дальнейшем использовать переменную sl, нужно
инициализировать срез, выполнив команду make, например, *sl = make([]sl, 10).

функция make используется только для создание срезов
make([]T, len, cap, ...elements)
каналов
make(chan T, bufferLength int)
и мапов
make(map[T1]T2)
Возвращает тип, соответствующий первому аргументу, а не указатель на него

9.
var x[]T (x == nil)
x := make([]T, length)
x := make([]T, length, capacity)
x := someArr[low:high]
x := []int{
    1,
    2,
    3,
}

var x map[T1]T2 (x == nil)
x := make(map[T1]T2)
x := map[int]int{
    1: 2,
    3: 4,
    5: 6,
}

10.
Выведет
1
1

func update(p *int) { //неявно создастся копия указателя на int
  b := 2
  p = &b //копия указателя и поменяется
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

//чтобы получить ожидаемый результат (1 2), необходимо передавать
указатель на указатель на int
func update(p **int) {
b := 2
*p = &b //теперь меняется сам указатель
}

func main() {
var (
a = 1
p = &a
)
fmt.Println(*p)
update(&p)
fmt.Println(*p)
}

11.
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) { //неявно создастся копия на структуру waitGroup
			fmt.Println(i)                  //5 add 0 done

			wg.Done()                       //результат - deadlock
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}

//решить проблему можно либо с помощью передачи в горутину wg по указателю
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg *sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(&wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}

//либо с помощью closure
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(i int) {
			fmt.Println(i)
			wg.Done()
		}(i)
	}
	wg.Wait()
	fmt.Println("exit")
}

12.
0
func main() {
  n := 0
  if true {
     n := 1 //создание новой переменной n с областью видимости внутри if'a
     n++
  }
  fmt.Println(n)
}

13.
По аналогии с вопросом №10
срез - указатель
неявно создастся копия этого указателя
func someAction(v []int8, b int8) {
  v[0] = 100 //разыменование (в языке C выглядело бы *(v+0)=100)
  v = append(v, b)//изменение копии указателя - изменений вне тела функции не последует
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a) // [100, 2, 3, 4, 5]
}

14.

func main() {
	slice := []string{"a", "a"}

	func(slice []string) {
		slice = append(slice, "a") //теперь переменная slice - указатель
		                           //на другой массив (append позвращает []T - указатель)
		                           //значения этого массива и будут меняться
		slice[0] = "b"
		slice[1] = "b"
		fmt.Print(slice)
	}(slice)
	fmt.Print(slice) //поэтому [b, b, a][a, a]
}


